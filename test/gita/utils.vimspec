let s:is_windows = has('win16') || has('win32') || has('win64')

Describe gita#utils
  Before
    Init
  End

  Context #import({name})
    It should return an instance of a specified vital module
      let ret = gita#import('Prelude')  " under 'vim_gita'
      let exp = Import('Prelude')       " under 'vital'
      " Note:
      "   funcrefs inside ret/exp are different while they comes from
      "   different namespace, so compare only keys
      Assert Equals(sort(keys(ret)), sort(keys(exp)))
    End

    It should return a same instance of a specified vital module
      let ret1 = gita#import('Prelude')
      let ret2 = gita#import('Prelude')
      let ret3 = gita#import('System.Filepath')
      Assert Equals(ret1, ret2)
      Assert Same(ret1, ret2)
      Assert NotEquals(ret1, ret3)
      Assert NotSame(ret1, ret3)
    End
  End

  Context #format_string({format}, {format_map}, {data})
    It should return an empty string if an empty {format} is given
      let ret = gita#utils#format_string('', {}, {})
      Assert Equals(ret, '')
    End

    It should return a formatted string
      let format = '%foo %bar %hoge'
      let format_map = {
            \ 'foo': 'foo_value',
            \ 'bar': 'bar_value',
            \ 'hoge': 'hoge_value',
            \}
      let data = {
            \ 'foo_value': 'Hello',
            \ 'bar_value': 'Good',
            \ 'hoge_value': 'Bye',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, 'Hello Good Bye')
    End

    It should add <left> value of %{<left>}<key> format if <key> is not empty
      let format = '%{Very }bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': 'Good',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, 'Very Good')
    End

    It should NOT add <left> value of %{<left>}<key> format if <key> is empty
      let format = '%{Very }bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': '',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, '')
    End

    It should add <right> value of %{|<right>}<key> format if <key> is not empty
      let format = '%{| Bye}bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': 'Good',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, 'Good Bye')
    End

    It should NOT add <right> value of %{|<right>}<key> format if <key> is empty
      let format = '%{| Bye}bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': '',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, '')
    End

    It should add <left> and <right> value of %{<left>|<right>}<key> format if <key> is not empty
      let format = '%{Hello | Bye}bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': 'Good',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, 'Hello Good Bye')
    End

    It should NOT add <left> and <right> value of %{<left>|<right>}<key> format if <key> is empty
      let format = '%{Hello | Bye}bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': '',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, '')
    End
  End

  Context #eget({obj}, {name}, {default})
    It should return {obj}.{name} if {obj} has {name} entry
      let obj = { 'foo': 'foo' }
      let ret = gita#utils#eget(obj, 'foo', 'bar')
      Assert Equals(ret, 'foo')
    End

    It should return {default} if {obj} does not have {name} entry
      let obj = { 'hoge': 'foo' }
      let ret = gita#utils#eget(obj, 'foo', 'bar')
      Assert Equals(ret, 'bar')
    End

    It should return {default} if {obj}.{name} is empty
      let obj = { 'foo': '' }
      let ret = gita#utils#eget(obj, 'foo', 'bar')
      Assert Equals(ret, 'bar')

      let obj = { 'foo': [] }
      let ret = gita#utils#eget(obj, 'foo', 'bar')
      Assert Equals(ret, 'bar')

      let obj = { 'foo': {} }
      let ret = gita#utils#eget(obj, 'foo', 'bar')
      Assert Equals(ret, 'bar')

      let obj = { 'foo': 0 }
      let ret = gita#utils#eget(obj, 'foo', 'bar')
      Assert Equals(ret, 'bar')
    End
  End

  Context #clip({content})
    It should assign {content} to @" register
      let @" = ""
      call gita#utils#clip('foo')
      Assert Equals(@", 'foo')
    End

    if has('clipboard')
      It should assign {content} to clipboard register
        call gita#utils#clip('foo')
        Assert Equals(getreg(v:register), 'foo')
      End
    endif
  End

  Context #expand({expr})
    Before
      WorkonInside
      let bufname = 'foo.txt'
      silent execute printf('new %s', bufname)
    End

    It should return 'filename' of gita meta when '%' is specified and filename is specified
      call gita#meta#set('filename', 'foobar.txt', '%')
      let ret = gita#utils#expand('%')
      Assert Equals(ret, 'foobar.txt')
    End

    It should return the current buffer when '%' is specified and no filename is specified
      call gita#meta#set('filename', '', '%')
      let ret = gita#utils#expand('%')
      Assert Equals(ret, bufname)
    End

    It should treat filename-modifiers
      call gita#meta#set('filename', 'foobar.txt', '%')
      let ret = gita#utils#expand('%:r')
      Assert Equals(ret, 'foobar')

      call gita#meta#set('filename', '', '%')
      let ret = gita#utils#expand('%:r')
      Assert Equals(ret, fnamemodify(bufname, ':r'))
    End

  End

  Context #ensure_abspath({path})
    Before
      WorkonInside
      let P = Import('System.Filepath')
      let file1 = 'foo.txt'
      call writefile(['foo'], file1)
    End
    After
      call delete(file1)
    End

    It should return {path} if {path} is already an absolute path
      let abspath = P.join(getcwd(), 'foo.txt')
      let ret = gita#utils#ensure_abspath(abspath)
      Assert Equals(ret, abspath)
      Assert Same(ret, abspath)
    End

    It should return an absolute path of {path} which exists
      let relpath = 'foo.txt'
      let ret = gita#utils#ensure_abspath(relpath)
      Assert NotSame(ret, relpath)
      Assert NotEquals(ret, relpath)
      Assert Equals(ret, fnamemodify(relpath, ':p'))
    End

    It should return an absolute path of {path} which does not exist
      let relpath = P.join('hoge', 'bar.txt')
      let ret = gita#utils#ensure_abspath(relpath)
      Assert NotSame(ret, relpath)
      Assert NotEquals(ret, relpath)
      " the behavior of ':p' is not defined for non existing file
      " thus opposite approach is required
      Assert Equals(fnamemodify(ret, ':~:.'), relpath)
    End
  End

  Context #ensure_relpath({path})
    Before
      WorkonInside
      let file1 = fnamemodify('foo.txt', ':p')
    End

    It should return {path} if {path} is already a relative path
      let relpath = 'foo.txt'
      let ret = gita#utils#ensure_relpath(relpath)
      Assert Equals(ret, relpath)
      Assert Same(ret, relpath)
    End

    It should return a relative path of {path}
      let abspath = file1
      let ret = gita#utils#ensure_relpath(abspath)
      Assert NotSame(ret, abspath)
      Assert NotEquals(ret, abspath)
      Assert Equals(ret, fnamemodify(abspath, ':~:.'))
    End
  End

  Context #ensure_pathlist({pathlist})
    Before
      WorkonInside
      let bufname = 'foo.txt'
      silent execute printf('new %s', bufname)
    End

    It should return a list of absolute path
      let pathlist = [
            \ '%',
            \ 'foo.txt',
            \ gita#utils#ensure_abspath('bar.txt'),
            \]
      let ret = gita#utils#ensure_pathlist(pathlist)
      Assert Equals(len(ret), 3)
      Assert Equals(ret[0], gita#utils#ensure_abspath(bufname))
      Assert Equals(ret[1], gita#utils#ensure_abspath('foo.txt'))
      Assert Equals(ret[2], gita#utils#ensure_abspath('bar.txt'))

    End
  End

  Context #ensure_unixpath({path))
    if !s:is_windows || !exists('&shellslash')
      It should return a same instance of {path} in non Windows OS or without +shellslash
        let path = 'C:\Foo\Bar\Hoge.txt'
        let ret = gita#utils#ensure_unixpath(path)
        Assert Equals(ret, path)
        Assert Same(ret, path)
      End
    else
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End

      It should return a same instance of {path} in Windows if shellslash is specified
        set shellslash
        let path = 'C:\Foo\Bar\Hoge.txt'
        let ret = gita#utils#ensure_unixpath(path)
        Assert NotEquals(ret, path)
        Assert NotSame(ret, path)
        Assert Equals(ret, 'C:/Foo/Bar/Hoge.txt')
      End

      It should return a modified instance of {path} in Windows if noshellslash is specified
        set noshellslash
        let path = 'C:\Foo\Bar\Hoge.txt'
        let ret = gita#utils#ensure_unixpath(path)
        Assert NotEquals(ret, path)
        Assert NotSame(ret, path)
        Assert Equals(ret, 'C:/Foo/Bar/Hoge.txt')
      End
    endif
  End

  Context #ensure_realpath({path))
    if !s:is_windows || !exists('&shellslash')
      It should return a same instance of {path} in non Windows OS or without +shellslash
        let path = 'C:/Foo/Bar/Hoge.txt'
        let ret = gita#utils#ensure_realpath(path)
        Assert Equals(ret, path)
        Assert Same(ret, path)
      End
    else
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End

      It should return a same instance of {path} in Windows if shellslash is specified
        set shellslash
        let path = 'C:/Foo/Bar/Hoge.txt'
        let ret = gita#utils#ensure_realpath(path)
        Assert Equals(ret, path)
        Assert Same(ret, path)
      End

      It should return a modified instance of {path} in Windows if noshellslash is specified
        set noshellslash
        let path = 'C:/Foo/Bar/Hoge.txt'
        let ret = gita#utils#ensure_realpath(path)
        Assert NotEquals(ret, path)
        Assert NotSame(ret, path)
        Assert Equals(ret, 'C:\Foo\Bar\Hoge.txt')
      End
    endif
  End

  Context #ensure_unixpathlist({pathlist})
    if !s:is_windows || !exists('&shellslash')
      It should works as same as gita#utils#ensure_pathlist in non Windows or without +shellslash
        let pathlist = [
              \ 'C:\Foo\Bar\Hoge.txt',
              \ 'Piyo.txt',
              \ '%',
              \]
        let ret = gita#utils#ensure_unixpathlist(pathlist)
        let exp = gita#utils#ensure_pathlist(pathlist)
        Assert Equals(ret, exp)
      End
    else
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End

      It should works as same as gita#utils#ensure_pathlist in Windows if shellslash is specified
        set shellslash
        let pathlist = [
              \ 'C:\Foo\Bar\Hoge.txt',
              \ 'Piyo.txt',
              \ '%',
              \]
        let ret = gita#utils#ensure_unixpathlist(pathlist)
        let exp = gita#utils#ensure_pathlist(pathlist)
        Assert NotEquals(ret, exp)
        Assert Equals(ret, map(exp, 'fnamemodify(v:val, '':g?\\?/?'')'))
      End

      It should return a modified version of gita#utils#ensure_pathlist in Windows if noshellslash is specified
        set noshellslash
        let pathlist = [
              \ 'C:\Foo\Bar\Hoge.txt',
              \ 'Piyo.txt',
              \ '%',
              \]
        let ret = gita#utils#ensure_unixpathlist(pathlist)
        let exp = gita#utils#ensure_pathlist(pathlist)
        Assert NotEquals(ret, exp)
        Assert Equals(ret, map(exp, 'fnamemodify(v:val, '':g?\\?/?'')'))
      End
    endif
  End

  Context #ensure_realpathlist({pathlist})
    if !s:is_windows || !exists('&shellslash')
      It should works as same as gita#utils#ensure_pathlist in non Windows or without +shellslash
        let pathlist = [
              \ 'C:/Foo/Bar/Hoge.txt',
              \ 'Piyo.txt',
              \ '%',
              \]
        let ret = gita#utils#ensure_realpathlist(pathlist)
        let exp = gita#utils#ensure_pathlist(pathlist)
        Assert Equals(ret, exp)
      End
    else
      Before
        let saved_shellslash = &shellslash
      End
      After
        let &shellslash = saved_shellslash
      End

      It should works as same as gita#utils#ensure_pathlist in Windows if shellslash is specified
        set shellslash
        let pathlist = [
              \ 'C:/Foo/Bar/Hoge.txt',
              \ 'Piyo.txt',
              \ '%',
              \]
        let ret = gita#utils#ensure_realpathlist(pathlist)
        let exp = gita#utils#ensure_pathlist(pathlist)
        Assert Equals(ret, exp)
      End

      It should return a modified version of gita#utils#ensure_pathlist in Windows if noshellslash is specified
        set noshellslash
        let pathlist = [
              \ 'C:/Foo/Bar/Hoge.txt',
              \ 'Piyo.txt',
              \ '%',
              \]
        let ret = gita#utils#ensure_realpathlist(pathlist)
        let exp = gita#utils#ensure_pathlist(pathlist)
        Assert NotEquals(ret, exp)
        Assert Equals(ret, map(exp, 'fnamemodify(v:val, '':g?/?\\?'')'))
      End
    endif
  End

End
