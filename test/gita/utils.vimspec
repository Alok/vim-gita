Describe gita#utils
  Context #import({name})
    It should return an instance of a specified vital module
      let ret = gita#utils#import('Prelude')
      let exp = g:V.import('Prelude')
      Assert Equals(ret, exp)
    End

    It should return a same instance of a specified vital module
      let ret1 = gita#utils#import('Prelude')
      let ret2 = gita#utils#import('Prelude')
      let ret3 = gita#utils#import('System.Filepath')
      Assert Equals(ret1, ret2)
      Assert Same(ret1, ret2)
      Assert NotEquals(ret1, ret3)
      Assert NotSame(ret1, ret3)
    End
  End

  Context #format_string({format}, {format_map}, {data})
    It should return an empty string if an empty {format} is given
      let ret = gita#utils#format_string('', {}, {})
      Assert Equals(ret, '')
    End

    It should return a formatted string
      let format = '%foo %bar %hoge'
      let format_map = {
            \ 'foo': 'foo_value',
            \ 'bar': 'bar_value',
            \ 'hoge': 'hoge_value',
            \}
      let data = {
            \ 'foo_value': 'Hello',
            \ 'bar_value': 'Good',
            \ 'hoge_value': 'Bye',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, 'Hello Good Bye')
    End

    It should add <left> value of %{<left>}<key> format if <key> is not empty
      let format = '%{Very }bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': 'Good',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, 'Very Good')
    End

    It should NOT add <left> value of %{<left>}<key> format if <key> is empty
      let format = '%{Very }bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': '',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, '')
    End

    It should add <right> value of %{|<right>}<key> format if <key> is not empty
      let format = '%{| Bye}bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': 'Good',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, 'Good Bye')
    End

    It should NOT add <right> value of %{|<right>}<key> format if <key> is empty
      let format = '%{| Bye}bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': '',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, '')
    End

    It should add <left> and <right> value of %{<left>|<right>}<key> format if <key> is not empty
      let format = '%{Hello | Bye}bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': 'Good',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, 'Hello Good Bye')
    End

    It should NOT add <left> and <right> value of %{<left>|<right>}<key> format if <key> is empty
      let format = '%{Hello | Bye}bar'
      let format_map = {
            \ 'bar': 'bar_value',
            \}
      let data = {
            \ 'bar_value': '',
            \}
      let ret = gita#utils#format_string(format, format_map, data)
      Assert Equals(ret, '')
    End
  End

  Context #expand({expr})
    Before
      let bufname = g:P.join(g:repository_root, 'foo.txt')
      silent execute printf('new %s', bufname)
    End
    After
      call WipeoutAll()
    End

    It should return 'original_filename' when '%' is specified and original_filename is specified
      call gita#set_original_filename('foobar.txt', '%')
      let ret = gita#utils#expand('%')
      Assert Equals(ret, 'foobar.txt')
    End

    It should return the current buffer when '%' is specified and no original_filename is specified
      call gita#set_original_filename('', '%')
      let ret = gita#utils#expand('%')
      Assert Equals(ret, bufname)
    End

    It should treat filename-modifiers
      call gita#set_original_filename('foobar.txt', '%')
      let ret = gita#utils#expand('%:r')
      Assert Equals(ret, 'foobar')

      call gita#set_original_filename('', '%')
      let ret = gita#utils#expand('%:r')
      Assert Equals(ret, fnamemodify(bufname, ':r'))
    End

  End

  Context #ensure_abspath({path})
    Before
      let saved_cwd = getcwd()
      let file1 = g:P.join(g:repository_root, 'foo.txt')
      let file2 = g:P.join(g:repository_root, 'hoge', 'bar.txt')
      execute printf('cd %s', g:repository_root)
      call writefile(['foo'], file1)
    End
    After
      execute printf('cd %s', saved_cwd)
      call delete(file1)
    End

    It should return {path} if {path} is already an absolute path
      let abspath = g:P.join(g:repository_root, 'foo.txt')
      let ret = gita#utils#ensure_abspath(abspath)
      Assert Equals(ret, abspath)
      Assert Same(ret, abspath)
    End

    It should return an absolute path of {path} which exists
      let relpath = 'foo.txt'
      let ret = gita#utils#ensure_abspath(relpath)
      Assert NotSame(ret, relpath)
      Assert NotEquals(ret, relpath)
      Assert Equals(ret, fnamemodify(relpath, ':p'))
    End

    It should return an absolute path of {path} which does not exist
      let relpath = g:P.join('hoge', 'bar.txt')
      let ret = gita#utils#ensure_abspath(relpath)
      Assert NotSame(ret, relpath)
      Assert NotEquals(ret, relpath)
      " the behavior of ':p' is not defined for non existing file
      " thus opposite approach is required
      Assert Equals(fnamemodify(ret, ':~:.'), relpath)
    End
  End

  Context #ensure_relpath({path})
    Before
      let saved_cwd = getcwd()
      let file1 = g:P.join(g:repository_root, 'foo.txt')
      execute printf('cd %s', g:repository_root)
    End
    After
      execute printf('cd %s', saved_cwd)
    End

    It should return {path} if {path} is already a relative path
      let relpath = 'foo.txt'
      let ret = gita#utils#ensure_relpath(relpath)
      Assert Equals(ret, relpath)
      Assert Same(ret, relpath)
    End

    It should return a relative path of {path}
      let abspath = file1
      let ret = gita#utils#ensure_relpath(abspath)
      Assert NotSame(ret, abspath)
      Assert NotEquals(ret, abspath)
      Assert Equals(ret, fnamemodify(abspath, ':~:.'))
    End
  End

  Context #ensure_pathlist({pathlist})
    Before
      let bufname = g:P.join(g:repository_root, 'foo.txt')
      silent execute printf('new %s', bufname)
    End
    After
      call WipeoutAll()
    End

    It should return a list of absolute path
      let pathlist = [
            \ '%',
            \ 'foo.txt',
            \ gita#utils#ensure_abspath('bar.txt'),
            \]
      let ret = gita#utils#ensure_pathlist(pathlist)
      Assert Equals(len(ret), 3)
      Assert Equals(ret[0], gita#utils#ensure_abspath(bufname))
      Assert Equals(ret[1], gita#utils#ensure_abspath('foo.txt'))
      Assert Equals(ret[2], gita#utils#ensure_abspath('bar.txt'))

    End
  End
End

