let s:V = vital#of('vital')
let s:Path = s:V.import('System.Filepath')
let s:Guard = s:V.import('Vim.Guard')
let s:ScriptLocal = s:V.import('Vim.ScriptLocal')
let s:scriptfile = s:Path.realpath('autoload/gita/core.vim')

Describe gita#core
  Before
    Init
    let Path = s:V.import('System.Filepath')
    let sf = s:ScriptLocal.sfuncs(s:scriptfile)
    let sv = s:ScriptLocal.svars(s:scriptfile)
    let guard = s:Guard.store(
          \ ['references', sv],
          \)
    let saved_getcwd = getcwd()
  End

  After
    call guard.restore()
    execute printf('cd %s', fnameescape(saved_getcwd))
    windo bwipeout!
  End

  Describe s:get_available_refname({refname})
    It returns {refname} if there is no confliction
      let refname = 'foo'
      Assert Equals(sf.get_available_refname(refname), refname)
      Assert Same(sf.get_available_refname(refname), refname)
    End

    It returns {refname}~<N> if there are conflictions
      let sv.references['foo'] = {}
      let refname = 'foo'
      Assert Equals(sf.get_available_refname(refname), refname . '~1')

      let sv.references['foo~1'] = {}
      Assert Equals(sf.get_available_refname(refname), refname . '~2')

      let sv.references['foo~2'] = {}
      Assert Equals(sf.get_available_refname(refname), refname . '~3')
    End
  End

  Describe s:is_expired({expr}, {refinfo})
    It returns 1 if git instance in {refinfo} is reserved to be expired
      let refinfo = {
            \ 'git': { 'is_expired': 1 },
            \ 'bufname': 'foo',
            \ 'cwd': getcwd()
            \}
      Assert Equals(sf.is_expired('%', refinfo), 1)
    End

    Context in file-like buffer
      It returns 1 if buffer name has changed from bufname in {refinfo}
        let refinfo = { 'bufname': 'foo', 'cwd': getcwd() }
        file bar
        for buftype in ['', 'nowrite', 'acwrite']
          execute printf('setlocal buftype=%s', buftype)
          Assert Equals(sf.is_expired('%', refinfo), 1)
        endfor
      End

      It returns 0 if buffer name is equal to bufname in {refinfo}
        let refinfo = { 'bufname': 'foo', 'cwd': getcwd() }
        file foo
        for buftype in ['', 'nowrite', 'acwrite']
          execute printf('setlocal buftype=%s', buftype)
          Assert Equals(sf.is_expired('%', refinfo), 0)
        endfor
      End
    End

    Context in non-file buffer
      It returns 1 if cwd has changed from cwd in {refinfo}
        let refinfo = { 'bufname': 'foo', 'cwd': 'somewhere' }
        for buftype in ['nofile', 'quickfix', 'help']
          Assert Equals(sf.is_expired('%', refinfo), 1)
        endfor
      End

      It returns 0 if cwd is equal to cwd in {refinfo}
        let refinfo = { 'bufname': 'foo', 'cwd': getcwd() }
        for buftype in ['nofile', 'quickfix', 'help']
          Assert Equals(sf.is_expired('%', refinfo), 1)
        endfor
      End
    End
  End

  Describe #get([{expr}, {options}])
    Context A file buffer in a git repository
      Before
        WorkonInside
        let bufname = s:Path.join(g:gita#test#inside, 'foo.txt')
        silent execute printf('new %s', bufname)
      End
      It returns a git instance
        let git = gita#core#get(bufname)
        Assert Equals(git.is_enabled, 1)
      End
      It returns a same git instance
        let git1 = gita#core#get(bufname)
        let git2 = gita#core#get(bufname)
        Assert Same(git1, git2)
      End
      It returns a same git instance for a same repository
        let git1 = gita#core#get(bufname)
        silent execute printf('file %s', bufname . '.mod')
        let git2 = gita#core#get(bufname . '.mod')
        Assert Same(git1, git2)
      End
    End

    Context A file buffer in a non git repository
      Before
        WorkonInside
        let bufname = s:Path.join(g:gita#test#outside, 'foo.txt')
        silent execute printf('new %s', bufname)
      End
      It returns a git instance while cwd is in a git repository
        let git = gita#core#get(bufname)
        Assert Equals(git.is_enabled, 1)
      End
      It returns a git instance but not enabled if cwd is not in a git repository
        WorkonOutside
        let git = gita#core#get(bufname)
        Assert Equals(git.is_enabled, 0)
      End
      It returns a same git instance
        let git1 = gita#core#get(bufname)
        let git2 = gita#core#get(bufname)
        Assert Same(git1, git2)
      End
      It does not return a same git instance if bufname has changed
        let git1 = gita#core#get(bufname)
        silent execute printf('file %s', bufname . '.mod')
        let git2 = gita#core#get(bufname . '.mod')
        Assert Same(git1, git2)
      End
    End

    Context A non file buffer
      Before
        WorkonInside
        let bufname = 'non-file'
        silent execute printf('new %s', bufname)
        setlocal buftype=nofile
      End
      It returns a git instance while cwd is in a git repository
        let git = gita#core#get(bufname)
        Assert Equals(git.is_enabled, 1)
      End
      It returns a git instance but not enabled if cwd is not in a git repository
        WorkonOutside
        let git = gita#core#get(bufname)
        Assert Equals(git.is_enabled, 0)
      End
      It returns a same git instance
        let git1 = gita#core#get(bufname)
        let git2 = gita#core#get(bufname)
        Assert Same(git1, git2)
      End
      It does not return a same git instance if a current working directory has changed
        let git1 = gita#core#get(bufname)
        WorkonOutside
        let git2 = gita#core#get(bufname)
        Assert NotSame(git1, git2)
      End
    End

    Context A gita buffer
      It throw an exception if {refname} of the buffer name does not exists in cache
        file gita://unknown
        Throws /No repository reference for unknown is found/ gita#core#get('%')
        file gita://unknown/foo
        Throws /No repository reference for unknown is found/ gita#core#get('%')
        file gita://unknown:foo
        Throws /No repository reference for unknown is found/ gita#core#get('%')
        file gita:unknown
        Throws /No repository reference for unknown is found/ gita#core#get('%')
        file gita:unknown/foo
        Throws /No repository reference for unknown is found/ gita#core#get('%')
        file gita:unknown:foo
        Throws /No repository reference for unknown is found/ gita#core#get('%')
      End

      It returns a cached git instance for {refname}
        let git = { 'is_enabled': 1 }
        let sv.references['foo'] = git
        file gita://foo
        Assert Equals(gita#core#get('%'), git)
        Assert Same(gita#core#get('%'), git)
        file gita://foo/bar
        Assert Equals(gita#core#get('%'), git)
        Assert Same(gita#core#get('%'), git)
        file gita://foo:bar
        Assert Equals(gita#core#get('%'), git)
        Assert Same(gita#core#get('%'), git)
        file gita:foo
        Assert Equals(gita#core#get('%'), git)
        Assert Same(gita#core#get('%'), git)
        file gita:foo/bar
        Assert Equals(gita#core#get('%'), git)
        Assert Same(gita#core#get('%'), git)
        file gita:foo:bar
        Assert Equals(gita#core#get('%'), git)
        Assert Same(gita#core#get('%'), git)
      End
    End
  End

  Describe #get_or_fail([{expr}, {options}])
    It throws an exception if git instance is not enabled
      let git = { 'is_enabled': 0 }
      let sv.references['foo'] = git
      file gita:foo
      Throws /Git is not available/ gita#core#get_or_fail('%')
    End

    It returns a git instance if it is enabled
      let git = { 'is_enabled': 1 }
      let sv.references['foo'] = git
      file gita:foo
      Assert Equals(gita#core#get_or_fail('%'), git)
      Assert Same(gita#core#get_or_fail('%'), git)
    End
  End

  Describe #expire([{expr}])
    It reserve git as expired
      let git = { 'is_enabled': 1 }
      let sv.references['foo'] = git
      let refinfo = { 'git': git, 'bufname': bufname('%'), 'cwd': getcwd() }
      Assert Equals(sf.is_expired('%', refinfo), 0)
      file gita:foo
      call gita#core#expire('%')
      Assert Equals(sf.is_expired('%', refinfo), 1)
    End
  End
End

