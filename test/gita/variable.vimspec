let s:V = vital#of('vital')
let s:Path = s:V.import('System.Filepath')
let s:ScriptLocal = s:V.import('Vim.ScriptLocal')
let s:file = s:Path.realpath('autoload/gita/variable.vim')

Describe gita#variable
  Before
    let g:gita#test = 1
  End

  Describe gita#variable#get_valid_commit({git}, {commit}[ {options}])
    It return {commit} if {commit} is valid
      let git = gita#core#get_or_fail()
      let result = gita#variable#get_valid_commit(git, 'HEAD')
      Assert Equals(result, 'HEAD')
    End

    It ask users to fill commit when {commit} is empty
      " NOTE:
      " While g:gita#test=1, it throw 'Cancel' instead
      let git = gita#core#get_or_fail()
      Throws /Cancel/ gita#variable#get_valid_commit(git, '')
    End

    It throw a validation error when {commit} is not valid
      let git = gita#core#get_or_fail()
      Throws /ValidationError/ gita#variable#get_valid_commit(git, 'HEAD~1')
      Throws /ValidationError/ gita#variable#get_valid_commit(git, 'HEAD:README.md')
      Throws /ValidationError/ gita#variable#get_valid_commit(git, 'HEAD~1:README.md')
      Throws /ValidationError/ gita#variable#get_valid_commit(git, 'HEAD..HEAD~1')
      Throws /ValidationError/ gita#variable#get_valid_commit(git, 'HEAD...HEAD~1')
    End
  End

  Describe gita#variable#get_valid_commitish({git}, {commitish}[ {options}])
    It return {commitish} if {commitish} is valid
      let git = gita#core#get_or_fail()
      let result = gita#variable#get_valid_commitish(git, 'HEAD')
      Assert Equals(result, 'HEAD')
      let result = gita#variable#get_valid_commitish(git, 'HEAD~1')
      Assert Equals(result, 'HEAD~1')
    End

    It ask users to fill commitish when {commitish} is empty
      " NOTE:
      " While g:gita#test=1, it throw 'Cancel' instead
      let git = gita#core#get_or_fail()
      Throws /Cancel/ gita#variable#get_valid_commitish(git, '')
    End

    It throw a validation error when {commitish} is not valid
      let git = gita#core#get_or_fail()
      Throws /ValidationError/ gita#variable#get_valid_commitish(git, 'HEAD~1:README.md')
      Throws /ValidationError/ gita#variable#get_valid_commitish(git, 'HEAD...HEAD~1')
    End
  End

  Describe gita#variable#get_valid_treeish({git}, {treeish}[ {options}])
    It return {treeish} if {treeish} is valid
      let git = gita#core#get_or_fail()
      let result = gita#variable#get_valid_treeish(git, 'HEAD')
      Assert Equals(result, 'HEAD')
      let result = gita#variable#get_valid_treeish(git, 'HEAD~1')
      Assert Equals(result, 'HEAD~1')
      let result = gita#variable#get_valid_treeish(git, 'HEAD:README.md')
      Assert Equals(result, 'HEAD:README.md')
      let result = gita#variable#get_valid_treeish(git, 'HEAD~1:README.md')
      Assert Equals(result, 'HEAD~1:README.md')
    End

    It ask users to fill treeish when {treeish} is empty
      " NOTE:
      " While g:gita#test=1, it throw 'Cancel' instead
      let git = gita#core#get_or_fail()
      Throws /Cancel/ gita#variable#get_valid_treeish(git, '')
    End

    It throw a validation error when {treeish} is not valid
      let git = gita#core#get_or_fail()
      Throws /ValidationError/ gita#variable#get_valid_treeish(git, 'HEAD..HEAD~1')
      Throws /ValidationError/ gita#variable#get_valid_treeish(git, 'HEAD...HEAD~1')
    End
  End

  Describe gita#variable#get_valid_range({git}, {range}[ {options}])
    It return {range} if {range} is valid
      let git = gita#core#get_or_fail()
      let result = gita#variable#get_valid_range(git, 'HEAD')
      Assert Equals(result, 'HEAD')
      let result = gita#variable#get_valid_range(git, 'HEAD~1')
      Assert Equals(result, 'HEAD~1')
      let result = gita#variable#get_valid_range(git, 'HEAD..HEAD~1')
      Assert Equals(result, 'HEAD..HEAD~1')
      let result = gita#variable#get_valid_range(git, 'HEAD...HEAD~1')
      Assert Equals(result, 'HEAD...HEAD~1')
    End

    It ask users to fill range when {range} is empty
      " NOTE:
      " While g:gita#test=1, it throw 'Cancel' instead
      let git = gita#core#get_or_fail()
      Throws /Cancel/ gita#variable#get_valid_range(git, '')
    End

    It throw a validation error when {range} is not valid
      let git = gita#core#get_or_fail()
      Throws /ValidationError/ gita#variable#get_valid_range(git, 'HEAD:README.md')
    End
  End

  Describe gita#variable#get_valid_filename({git}, {filename}[ {options}])
    It return {filename} if {filename} is valid
      let git = gita#core#get_or_fail()
      let result = gita#variable#get_valid_range(git, 'HEAD')
      Assert Equals(result, 'HEAD')
      let result = gita#variable#get_valid_range(git, 'HEAD~1')
      Assert Equals(result, 'HEAD~1')
      let result = gita#variable#get_valid_range(git, 'HEAD..HEAD~1')
      Assert Equals(result, 'HEAD..HEAD~1')
      let result = gita#variable#get_valid_range(git, 'HEAD...HEAD~1')
      Assert Equals(result, 'HEAD...HEAD~1')
    End

    It ask users to fill filename when {filename} is empty
      " NOTE:
      " While g:gita#test=1, it throw 'Cancel' instead
      let git = gita#core#get_or_fail()
      Throws /Cancel/ gita#variable#get_valid_range(git, '')
    End

    It throw a validation error when {filename} is not valid
      let git = gita#core#get_or_fail()
      Throws /ValidationError/ gita#variable#get_valid_range(git, 'HEAD:README.md')
    End
  End
End
