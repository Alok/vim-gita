let s:V = vital#of('vital')
let s:File = s:V.import('System.File')
let s:Path = s:V.import('System.Filepath')
let s:ScriptLocal = s:V.import('Vim.ScriptLocal')
let s:file = s:Path.realpath('autoload/vital/__gita__/Git/Process.vim')

Describe Git.Process
  Before all
    " Create a mock Git working tree
    let root = tempname()
    let worktree = s:Path.join(root, 'i n s i d e')
    let repository = s:Path.join(worktree, '.git')
    lockvar root
    lockvar worktree
    lockvar repository
    call mkdir(worktree, 'p')
    call system(printf('cd %s && git init', shellescape(worktree)))
  End
  After all
    " remove a temp directory
    call s:File.rmdir(root, 'r')
  End
  Before
    let GitProcess = vital#of('gita').import('Git.Process')
    let sf = s:ScriptLocal.sfuncs(s:file)
  End

  Describe .get_config()
    It returns a copy of a config dictionary
      let config = GitProcess.get_config()
      Assert IsDict(config)
      Assert KeyExists(config, 'executable')
      Assert KeyExists(config, 'arguments')

      let config2 = GitProcess.get_config()
      Assert Equals(config, config2)
      Assert NotSame(config, config2)
    End
  End

  Describe .set_config({config})
    Before
      let _config = GitProcess.get_config()
    End
    After
      call GitProcess.set_config(_config)
    End
    It overwrites existing config with {config}
      call GitProcess.set_config({
            \ 'executable': 'hub',
            \ 'arguments': [],
            \})
      let config = GitProcess.get_config()
      Assert Equals(config, {
            \ 'executable': 'hub',
            \ 'arguments': [],
            \})
    End
    It ignores unknown attributes
      call GitProcess.set_config({
            \ 'executable': 'hub',
            \ 'arguments': [],
            \ 'unknown_attribute': 'bar',
            \})
      let config = GitProcess.get_config()
      Assert Equals(config, {
            \ 'executable': 'hub',
            \ 'arguments': [],
            \})
    End
    It ignores missing attributes
      call GitProcess.set_config({
            \ 'executable': 'hub',
            \})
      let config = GitProcess.get_config()
      Assert Equals(config, {
            \ 'executable': 'hub',
            \ 'arguments': ['-c', 'color.ui=false', '--no-pager'],
            \})
    End
  End

  Describe .execute({git}, {args}[, {options}])
    It execute git command in {git.worktree} and return {result}
      let Path = s:Path
      let git = { 'worktree': worktree }
      let result = GitProcess.execute(git, [
            \ 'rev-parse', '--show-toplevel',
            \])
      Assert Equals(result.success, 1, result.output)
      " NOTE:
      " git rev-parse --show-toplevel returns an UNIX path even in Windows
      " NOTE:
      " A temporary directory is symlinked in Mac OS X
      Assert Equals(result.content, [Path.unixpath(resolve(worktree))])
    End

    It execute git command in the current working directory and return {result} if empty {git} is specified
      let Path = s:Path
      let git = {}
      let result = GitProcess.execute(git, [
            \ 'rev-parse', '--show-toplevel',
            \])
      Assert Equals(result.success, 1, result.output)
      " NOTE:
      " git rev-parse --show-toplevel returns an UNIX path even in Windows
      " NOTE:
      " A temporary directory is symlinked in Mac OS X
      Assert Equals(result.content, [Path.unixpath(resolve(getcwd()))])
    End
  End

  Describe .shell({git}, {args})
    It execute git command in {git.worktree} by :! command
      let Path = s:Path
      let git = { 'worktree': worktree }
      let git = {}
      " NOTE:
      " The stdout of :! could not be obtain by redir somehow
      call GitProcess.shell(git, [
            \ 'rev-parse', '--show-toplevel',
            \])
      Assert Equals(v:shell_error, 0)
    End
  End
End

" :!git ''-c'' ''color.ui=false'' ''--no-pager'' ''-C'' ''/var/folders/f_/dypbhlxd4cqg63lb40ykq0580000gn/T/vkK8Wvy/20/i n s i d e'' ''rev-parse'' ''--show-toplevel''
