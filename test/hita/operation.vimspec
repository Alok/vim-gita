let s:V = vital#of('vital')
let s:Path = s:V.import('System.Filepath')
let s:Guard = s:V.import('Vim.Guard')
let s:ScriptLocal = s:V.import('Vim.ScriptLocal')
let s:file = s:Path.realpath('autoload/hita/operation.vim')

Describe hita#operation
  Before
    Init
    let sf = s:ScriptLocal.sfuncs(s:file)
    let sv = s:ScriptLocal.svars(s:file)
  End

  Describe s:prefer_shellescape({val})
    if !g:is_windows
      It does not enclose {val} with quotes if {val} doesn't contain spaces
        Assert Equals(sf.prefer_shellescape('foobar'), 'foobar')
      End
      It encloses {val} with single quotes if {val} contains spaces
        Assert Equals(sf.prefer_shellescape('foo bar'), "'foo bar'")
      End
    elseif exists('&shellslash')
      Before
        let guard = s:Guard.store('&shellslash')
      End
      After
        call guard.restore()
      End
      It does not enclose {val} with quotes if {val} doesn't contain spaces
        Assert Equals(sf.prefer_shellescape('foobar'), 'foobar')
      End
      It encloses {val} with single quotes if {val} contains spaces and &shellslash=1
        set shellslash
        Assert Equals(sf.prefer_shellescape('foo bar'), "'foo bar'")
      End
      It encloses {val} with double quotes if {val} contains spaces and &shellslash=0
        set noshellslash
        Assert Equals(sf.prefer_shellescape('foo bar'), '"foo bar"')
      End
    else
      It does not enclose {val} with quotes if {val} doesn't contain spaces
        Assert Equals(sf.prefer_shellescape('foobar'), 'foobar')
      End
      It encloses {val} with double quotes if {val} contains spaces and -shellslash
        Assert Equals(sf.prefer_shellescape('foo bar'), '"foo bar"')
      End
    endif
  End

  Describe s:translate_option({key}, {val}, {pattern})
    Context Long format
      It returns "--key=value" for ('key', 'value', '')
        let ret = sf.translate_option('key', 'value', '')
        Assert Equals(ret, '--key=value')
      End
      if !g:is_windows || (exists('&shellslash') && &shellslash)
        It returns "--key='v a l u e'" for ('key', 'v a l u e', '')
          let ret = sf.translate_option('key', 'v a l u e', '')
          Assert Equals(ret, '--key=''v a l u e''')
        End
      else
        It returns '--key="v a l u e"' for ('key', 'v a l u e', '')
          let ret = sf.translate_option('key', 'v a l u e', '')
          Assert Equals(ret, '--key="v a l u e"')
        End
      endif
      It returns "--key" for ('key', 1, '')
        let ret = sf.translate_option('key', 1, '')
        Assert Equals(ret, '--key')
      End
      It returns "" for ('key', 0, '')
        let ret = sf.translate_option('key', 0, '')
        Assert Equals(ret, '')
      End
      It returns "-key-value-' for ('key', 'value', '-%k-%v-')
        let ret = sf.translate_option('key', 'value', '-%k-%v-')
        Assert Equals(ret, '-key-value-')
      End
      It returns "--h-e-l-l-o' for ('h_e_l_l_o', 1, '')
        let ret = sf.translate_option('h_e_l_l_o', 1, '')
        Assert Equals(ret, '--h-e-l-l-o')

        let ret = sf.translate_option('h_e_l_l_o', 1, '--%K')
        Assert Equals(ret, '--h-e-l-l-o')
      End
      It returns "--h_e_l_l_o' for ('h_e_l_l_o', 1, '--%k')
        let ret = sf.translate_option('h_e_l_l_o', 1, '--%k')
        Assert Equals(ret, '--h_e_l_l_o')
      End
      It returns "--key=value" for ('key', 'value', '--%K%{=}v')
        let ret = sf.translate_option('key', 'value', '--%K%{=}v')
        Assert Equals(ret, '--key=value')
      End
    End
    Context Short format
      It returns "-kvalue" for ('k', 'value', '')
        let ret = sf.translate_option('k', 'value', '')
        Assert Equals(ret, '-kvalue')
      End
      It returns "-k" for ('k', 1, '')
        let ret = sf.translate_option('k', 1, '')
        Assert Equals(ret, '-k')
      End
      It returns "" for ('k', 0, '')
        let ret = sf.translate_option('k', 0, '')
        Assert Equals(ret, '')
      End
      It returns "-kvalue" for ('k', 'value', '-%k%V')
        let ret = sf.translate_option('k', 'value', '-%k%V')
        Assert Equals(ret, '-kvalue')
      End
      if !g:is_windows || (exists('&shellslash') && &shellslash)
        It returns "-k'v a l u e'" for ('k', 'v a l u e', '-%k%V')
          let ret = sf.translate_option('k', 'v a l u e', '-%k%V')
          Assert Equals(ret, '-k''v a l u e''')
        End
      else
        It returns '-k"v a l u e"' for ('k', 'v a l u e', '-%k%V')
          let ret = sf.translate_option('k', 'v a l u e', '-%k%V')
          Assert Equals(ret, '-k"v a l u e"')
        End
      endif
    End
  End

  Describe s:translate_options({options}, {scheme})
    It translates options (dict) into arguments (list)
      let options = {
            \ 'foo': 1,
            \ 'bar': 0,
            \ 'hoge': 'hoge',
            \ 'f': 1,
            \ 'b': 0,
            \ 'h': 'hoge',
            \}
      let ret = sf.translate_options(options, {})
      Assert Equals(sort(ret), sort([
            \ '--foo',
            \ '--hoge=hoge',
            \ '-f',
            \ '-hhoge',
            \]))
    End
    It applies specified schemes of each option
      let options = {
            \ 'foo': 1,
            \ 'bar': 0,
            \ 'hoge': 'hoge',
            \}
      let scheme = {
            \ 'foo': '---%k',
            \ 'hoge': '%v',
            \}
      let ret = sf.translate_options(options, scheme)
      Assert Equals(sort(ret), sort([
            \ '---foo',
            \ 'hoge',
            \]))
    End
  End

  Describe s:execute({gita}, {args}, {config})
    Before
      let git = {}
      let git._called_with = []
      let git._args = []
      let git._stdout = 'stdout'
      let git._status = 0
      function! git.exec(...) abort
        call add(self._called_with, a:000)
        return {
              \ 'args':   self._args,
              \ 'stdout': self._stdout,
              \ 'status': self._status,
              \}
      endfunction
      let gita = {
            \ 'enabled': 1,
            \ 'git': deepcopy(git)
            \}
      let guard = s:Guard.store(
            \ ['GitCore', sv],
            \)
      call extend(sv.GitCore, git)
    End
    After
      call guard.restore()
    End
    It calls {gita}.git.exec when {gita}.enabled == 1
      call sf.execute(gita, ['foo', 'bar'], {})
      call sf.execute(gita, ['bar', 'bar'], {})
      let called_with = gita.git._called_with
      Assert Equals(called_with, [
            \ [['foo', 'bar'], {}],
            \ [['bar', 'bar'], {}],
            \])
      let called_with = sv.GitCore._called_with
      Assert Equals(called_with, [])
    End
    It calls s:GitCore.exec when {gita}.enabled == 0
      let gita.enabled = 0
      call sf.execute(gita, ['foo', 'bar'], {})
      call sf.execute(gita, ['bar', 'bar'], {})
      let called_with = gita.git._called_with
      Assert Equals(called_with, [])
      let called_with = sv.GitCore._called_with
      Assert Equals(called_with, [
            \ [['foo', 'bar'], {}],
            \ [['bar', 'bar'], {}],
            \])
    End
  End

  Describe #exec({gita}, {name}[, {options}, {config}])
    It is executable
      Assert True(exists('*hita#operation#exec'))
    End
  End
End

