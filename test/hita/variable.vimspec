let s:V = vital#of('vital')
let s:Path = s:V.import('System.Filepath')
let s:ScriptLocal = s:V.import('Vim.ScriptLocal')
let s:file = s:Path.realpath('autoload/hita/variable.vim')

Describe hita#variable
  Before
    let sf = s:ScriptLocal.sfuncs(s:file)
  End

  Describe hita#variable#split_commitish({commitish}[, {options}])
    It splits an empty {commitish}
      Assert Equals(
            \ hita#variable#split_commitish('', {}),
            \ ['', ''],
            \)
    End
    It splits {commitish} of <refname>@{<date>}
      Assert Equals(
            \ hita#variable#split_commitish('master@{yesterday}', {}),
            \ ['master', '@{yesterday}'],
            \)
      Assert Equals(
            \ hita#variable#split_commitish('HEAD@{5 minutes ago}', {}),
            \ ['HEAD', '@{5 minutes ago}'],
            \)
    End
    It splits {commitish} of <refname>@{<n>}
      Assert Equals(
            \ hita#variable#split_commitish('master@{1}', {}),
            \ ['master', '@{1}'],
            \)
    End
    It splits {commitish} of @{<n>}, @{-<n>}
      Assert Equals(
            \ hita#variable#split_commitish('@{1}', {}),
            \ ['', '@{1}'],
            \)
      Assert Equals(
            \ hita#variable#split_commitish('@{-1}', {}),
            \ ['', '@{-1}'],
            \)
    End
    It splits {commitish} of <branchname>@{upstream}, @{u}
      Assert Equals(
            \ hita#variable#split_commitish('develop@{upstream}', {}),
            \ ['develop', '@{upstream}'],
            \)
      Assert Equals(
            \ hita#variable#split_commitish('@{u}', {}),
            \ ['', '@{u}'],
            \)
    End
    It splits {commitish} of <rev>^<n>
      Assert Equals(
            \ hita#variable#split_commitish('HEAD^', {}),
            \ ['HEAD', '^'],
            \)
      Assert Equals(
            \ hita#variable#split_commitish('v1.5.1^0', {}),
            \ ['v1.5.1', '^0'],
            \)
      Assert Equals(
            \ hita#variable#split_commitish('develop^^', {}),
            \ ['develop', '^^'],
            \)
    End
    It splits {commitish} of <rev>~<n>
      Assert Equals(
            \ hita#variable#split_commitish('HEAD~', {}),
            \ ['HEAD', '~'],
            \)
      Assert Equals(
            \ hita#variable#split_commitish('master~3', {}),
            \ ['master', '~3'],
            \)
      Assert Equals(
            \ hita#variable#split_commitish('develop~~', {}),
            \ ['develop', '~~'],
            \)
    End
    It splits {commitish} of <rev>^{<type>}, <rev>^{}
      Assert Equals(
            \ hita#variable#split_commitish('v0.99.8^{commit}', {}),
            \ ['v0.99.8', '^{commit}'],
            \)
      Assert Equals(
            \ hita#variable#split_commitish('v0.99.8^{}', {}),
            \ ['v0.99.8', '^{}'],
            \)
    End
    It splits {commitish} of <rev>^{/<text>}
      Assert Equals(
            \ hita#variable#split_commitish('HEAD^{/fix nasty bug}', {}),
            \ ['HEAD', '^{/fix nasty bug}'],
            \)
    End
    It splits {commitish} of <rev>:/<text>
      Assert Equals(
            \ hita#variable#split_commitish('HEAD:/fix nasty bug', {}),
            \ ['HEAD', ':/fix nasty bug'],
            \)
    End
    It splits {commitish} of <refname>
      Assert Equals(
            \ hita#variable#split_commitish('HEAD', {}),
            \ ['HEAD', ''],
            \)
    End
    It throws an exception when failed to split
      Throws /no space, tilde \~, caret \^, or colon : are allowed/
            \ hita#variable#split_commitish('H:E:A:D', {})
    End
  End
  Describe hita#variable#split_treeish({treeish}[, {options}])
    It splits an empty {treeish}
      Assert Equals(
            \ hita#variable#split_treeish('', {}),
            \ ['', ''],
            \)
    End
    It splits {treeish} of <rev>:<path>
      Assert Equals(
            \ hita#variable#split_treeish('HEAD:README.md', {}),
            \ ['HEAD', 'README.md'],
            \)
      Assert Equals(
            \ hita#variable#split_treeish('develop^:autoload/gita/core.vim', {}),
            \ ['develop^', 'autoload/gita/core.vim'],
            \)
    End
    It splits {treeish} of :<n>:<path>
      Assert Equals(
            \ hita#variable#split_treeish(':0:README.md', {}),
            \ ['', 'README.md'],
            \)
      Assert Equals(
            \ hita#variable#split_treeish(':3:autoload/gita/core.vim', {}),
            \ ['', 'autoload/gita/core.vim'],
            \)
    End
    It throws an exception when failed to split
      Throws /no space, tilde \~, caret \^, or colon : are allowed/
            \ hita#variable#split_treeish('H E A D:README.md', {})
    End
  End
  Describe hita#variable#split_range({range}[, {options}])
    It splits an empty {range}
      Assert Equals(
            \ hita#variable#split_range('', {}),
            \ ['', ''],
            \)
    End
    It splits {range} of <rev1>...<rev2>
      Assert Equals(
            \ hita#variable#split_range('HEAD~4...develop', {}),
            \ ['HEAD~4', 'develop'],
            \)
      Assert Equals(
            \ hita#variable#split_range('...develop', {}),
            \ ['', 'develop'],
            \)
      Assert Equals(
            \ hita#variable#split_range('HEAD...', {}),
            \ ['HEAD', ''],
            \)
    End
    It splits {range} of <rev1>..<rev2>
      Assert Equals(
            \ hita#variable#split_range('HEAD~4..develop', {}),
            \ ['HEAD~4', 'develop'],
            \)
      Assert Equals(
            \ hita#variable#split_range('..develop', {}),
            \ ['', 'develop'],
            \)
      Assert Equals(
            \ hita#variable#split_range('HEAD..', {}),
            \ ['HEAD', ''],
            \)
    End
    It throws an exception when failed to split
      Throws /no space, tilde \~, caret \^, or colon : are allowed/
            \ hita#variable#split_range('H E A D...master', {})
      Throws /no space, tilde \~, caret \^, or colon : are allowed/
            \ hita#variable#split_range('HEAD...m a s t e r', {})
    End
  End

  Describe hita#variable#validate_commit({commit}[, {options}])
    It fails when {commit} begin with a dot or end with the sequence .lock
      Throws /no slash-separated component can begin with/
            \ hita#variable#validate_commit('foo/.bar', {})
      Throws /no slash-separated component can begin with/
            \ hita#variable#validate_commit('foo/bar.lock', {})
    End
    It fails when {commit} contains two consective dots ..
      Throws /no two consective dots/
            \ hita#variable#validate_commit('foo..bar', {})
    End
    It fails when {commit} contains space, tilde ~, caret ^, or colon :
      Throws /no space, tilde \~, caret ^, or colon : are allowed/
            \ hita#variable#validate_commit('foo bar', {})
      Throws /no space, tilde \~, caret ^, or colon : are allowed/
            \ hita#variable#validate_commit('foo~bar', {})
      Throws /no space, tilde \~, caret ^, or colon : are allowed/
            \ hita#variable#validate_commit('foo^bar', {})
      Throws /no space, tilde \~, caret ^, or colon : are allowed/
            \ hita#variable#validate_commit('foo:bar', {})
    End
    It fails when {commit} contains question ?, asterisk *, or open bracket [
      Throws /no question ?, asterisk \*, or open bracket \[/
            \ hita#variable#validate_commit('foo?bar', {})
      Throws /no question ?, asterisk \*, or open bracket \[/
            \ hita#variable#validate_commit('foo*bar', {})
      Throws /no question ?, asterisk \*, or open bracket \[/
            \ hita#variable#validate_commit('foo[bar', {})
    End
    It does not fail when {commit} contains asterisk * but 'refspec-pattern' is specified
      call hita#variable#validate_commit('foo*bar', {'refspec-pattern': 1})
    End
    It fails when {commit} begin or end with a slash /, or contain multiple consective slashes
      Throw /cannot begin or end with a slash \//
            \ hita#variable#validate_commit('/foobar', {})
      Throw /cannot begin or end with a slash \//
            \ hita#variable#validate_commit('foobar/', {})
      Throw /cannot begin or end with a slash \//
            \ hita#variable#validate_commit('foo//bar', {})
    End
    It does not fail when {commit} contains invalid slashes but 'normalize' is specified
      call hita#variable#validate_commit('/foobar', {'normalize': 1})
      call hita#variable#validate_commit('foobar/', {'normalize': 1})
      call hita#variable#validate_commit('foo//bar', {'normalize': 1})
      " 'print' is for backward compatiblity
      call hita#variable#validate_commit('/foobar', {'print': 1})
      call hita#variable#validate_commit('foobar/', {'print': 1})
      call hita#variable#validate_commit('foo//bar', {'print': 1})
    End
    It fails when {commit} ends with a dot
      Throws /cannot end with a dot/
            \ hita#variable#validate_commit('foobar.', {})
    End
    It fails when {commit} contains a sequence @{
      Throws /cannot contain a sequence/
            \ hita#variable#validate_commit('foo@{bar', {})
    End
    It fails when {commit} is a single character @
      Throws /cannot be a single character @/
            \ hita#variable#validate_commit('@', {})
    End
    It fails when {commit} contains a backslash
      Throws /cannot contain a backslash/
            \ hita#variable#validate_commit('\', {})
    End
  End
  Describe hita#variable#validate_commitish({commitish}[, {options}])
    It does not fail if {commitish} is <refname>@{<date>|<n>|upstream|u}
      call hita#variable#validate_commitish('master@{yesterday}', {})
      call hita#variable#validate_commitish('HEAD@{5 minutes ago}', {})
      call hita#variable#validate_commitish('master@{1}', {})
      call hita#variable#validate_commitish('@{1}', {})
      call hita#variable#validate_commitish('@{-1}', {})
      call hita#variable#validate_commitish('develop@{upstream}', {})
      call hita#variable#validate_commitish('@{u}', {})
    End
    It does not fail if {commitish} is <rev>^<n>
      call hita#variable#validate_commitish('HEAD^', {})
      call hita#variable#validate_commitish('v1.5.1^0', {})
      call hita#variable#validate_commitish('develop^^', {})
    End
    It does not fail if {commitish} is <rev>~<n>
      call hita#variable#validate_commitish('HEAD~', {})
      call hita#variable#validate_commitish('master~3', {})
      call hita#variable#validate_commitish('develop~~', {})
    End
    It does not fail if {commitish} is <rev>^{<type}, <rev>^{}
      call hita#variable#validate_commitish('v0.99.8^{commit}', {})
      call hita#variable#validate_commitish('v0.99.8^{}', {})
    End
    It does not fail if {commitish} is <rev>^{/<text>}, <ref>:/<text>
      call hita#variable#validate_commitish('HEAD^{/fix nasty bug}', {})
      call hita#variable#validate_commitish('HEAD:/fix nasty bug', {})
    End
  End
  Describe hita#variable#validate_treeish({treeish}[, {options}])
    It does not fail if {treeish} is <rev>:<path>
      call hita#variable#validate_treeish('HEAD:README.md', {})
      call hita#variable#validate_treeish('master:autoload/gita/core.vim', {})
    End
    It does not fail if {treeish} is :<n>:<path>
      call hita#variable#validate_treeish(':0:README.md', {})
      call hita#variable#validate_treeish(':3:autoload/gita/core.vim', {})
    End
  End
  Describe hita#variable#validate_range({range}[, {options}])
    It does not fail if {range} is <rev1>...<rev2>
      call hita#variable#validate_range('HEAD~4...develop', {})
    End
    It does not fail if {treeish} is <rev1>..<rev2>
      call hita#variable#validate_range('HEAD~4..develop', {})
    End
  End
End
